{
  "version": 3,
  "sources": [
    "/usr/local/lib/node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "/home/ubuntu/projects/polygon-clipper/index.js",
    "/home/ubuntu/projects/polygon-clipper/node_modules/fast-list/fast-list.js",
    "/home/ubuntu/projects/polygon-clipper/node_modules/geojson-allrings/index.js",
    "/home/ubuntu/projects/polygon-clipper/node_modules/intersection/index.js",
    "/home/ubuntu/projects/polygon-clipper/src/aet.js",
    "/home/ubuntu/projects/polygon-clipper/src/bound.js",
    "/home/ubuntu/projects/polygon-clipper/src/clipper.js",
    "/home/ubuntu/projects/polygon-clipper/src/it.js",
    "/home/ubuntu/projects/polygon-clipper/src/local-minima-list.js",
    "/home/ubuntu/projects/polygon-clipper/src/polygon.js",
    "/home/ubuntu/projects/polygon-clipper/src/precision.js",
    "/home/ubuntu/projects/polygon-clipper/src/sorted-linked-list.js",
    "/home/ubuntu/projects/polygon-clipper/src/st.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "var Clipper = require('./src/clipper.js');\n\nmodule.exports = function(subj,clip,process,precision) {\n  var instance = new Clipper();\n  return instance.overlay(subj, clip, process);\n};\n\n",
    ";(function() { // closure for web browsers\n\nfunction Item (data, prev, next) {\n  this.next = next\n  if (next) next.prev = this\n  this.prev = prev\n  if (prev) prev.next = this\n  this.data = data\n}\n\nfunction FastList () {\n  if (!(this instanceof FastList)) return new FastList\n  this._head = null\n  this._tail = null\n  this.length = 0\n}\n\nFastList.prototype =\n{ push: function (data) {\n    this._tail = new Item(data, this._tail, null)\n    if (!this._head) this._head = this._tail\n    this.length ++\n  }\n\n, pop: function () {\n    if (this.length === 0) return undefined\n    var t = this._tail\n    this._tail = t.prev\n    if (t.prev) {\n      t.prev = this._tail.next = null\n    }\n    this.length --\n    if (this.length === 1) this._head = this._tail\n    else if (this.length === 0) this._head = this._tail = null\n    return t.data\n  }\n\n, unshift: function (data) {\n    this._head = new Item(data, null, this._head)\n    if (!this._tail) this._tail = this._head\n    this.length ++\n  }\n\n, shift: function () {\n    if (this.length === 0) return undefined\n    var h = this._head\n    this._head = h.next\n    if (h.next) {\n      h.next = this._head.prev = null\n    }\n    this.length --\n    if (this.length === 1) this._tail = this._head\n    else if (this.length === 0) this._head = this._tail = null\n    return h.data\n  }\n\n, item: function (n) {\n    if (n < 0) n = this.length + n\n    var h = this._head\n    while (n-- > 0 && h) h = h.next\n    return h ? h.data : undefined\n  }\n\n, slice: function (n, m) {\n    if (!n) n = 0\n    if (!m) m = this.length\n    if (m < 0) m = this.length + m\n    if (n < 0) n = this.length + n\n\n    if (m === n) {\n      return []\n    }\n\n    if (m < n) {\n      throw new Error(\"invalid offset: \"+n+\",\"+m+\" (length=\"+this.length+\")\")\n    }\n\n    var len = m - n\n      , ret = new Array(len)\n      , i = 0\n      , h = this._head\n    while (n-- > 0 && h) h = h.next\n    while (i < len && h) {\n      ret[i++] = h.data\n      h = h.next\n    }\n    return ret\n  }\n\n, drop: function () {\n    FastList.call(this)\n  }\n\n, forEach: function (fn, thisp) {\n    var p = this._head\n      , i = 0\n      , len = this.length\n    while (i < len && p) {\n      fn.call(thisp || this, p.data, i, this)\n      p = p.next\n      i ++\n    }\n  }\n\n, map: function (fn, thisp) {\n    var n = new FastList()\n    this.forEach(function (v, i, me) {\n      n.push(fn.call(thisp || me, v, i, me))\n    })\n    return n\n  }\n\n, filter: function (fn, thisp) {\n    var n = new FastList()\n    this.forEach(function (v, i, me) {\n      if (fn.call(thisp || me, v, i, me)) n.push(v)\n    })\n    return n\n  }\n\n, reduce: function (fn, val, thisp) {\n    var i = 0\n      , p = this._head\n      , len = this.length\n    if (!val) {\n      i = 1\n      val = p && p.data\n      p = p && p.next\n    }\n    while (i < len && p) {\n      val = fn.call(thisp || this, val, p.data, this)\n      i ++\n      p = p.next\n    }\n    return val\n  }\n}\n\nif (\"undefined\" !== typeof(exports)) module.exports = FastList\nelse if (\"function\" === typeof(define) && define.amd) {\n  define(\"FastList\", function() { return FastList })\n} else (function () { return this })().FastList = FastList\n\n})()\n",
    "//index.js\n(function() {\n  function allrings(polygon) {\n    var rings;\n    if(polygon.type && polygon.coordinates) {\n      if (polygon.type === 'Polygon') {\n        rings = polygon.coordinates;\n      } else if (polygon.type === 'MultiPolygon') {\n        rings = polygon.coordinates.reduce(function(prev,cur) {\n          return prev.concat(cur);\n        },[]);\n      }\n    }\n    return rings;\n  }\n  if(typeof module !== 'undefined' && module.exports) {\n    module.exports = allrings;\n  } else if (window) {\n    window.geojsonAllRings = allrings;\n  }\n})();\n",
    "var intersection = function() {\n    var vector = {};\n    vector.oA = function(segment) {\n        return segment.start;\n    };\n    vector.AB = function(segment) {\n        var start = segment.start;\n        var end = segment.end;\n        return {x:end.x - start.x, y: end.y - start.y};\n    };\n    vector.add = function(v1,v2) {\n        return {x: v1.x + v2.x, y: v1.y + v2.y};\n    }\n    vector.sub = function(v1,v2) {\n        return {x:v1.x - v2.x, y: v1.y - v2.y};\n    }\n    vector.scalarMult = function(s, v) {\n        return {x: s * v.x, y: s * v.y};\n    }\n    vector.crossProduct = function(v1,v2) {\n        return (v1.x * v2.y) - (v2.x * v1.y);\n    };\n    var self = {};\n    self.vector = function(segment) {\n        return vector.AB(segment);\n    };\n    self.intersectSegments = function(a,b) {\n        // turn a = p + t*r where 0<=t<=1 (parameter)\n        // b = q + u*s where 0<=u<=1 (parameter) \n        var p = vector.oA(a);\n        var r = vector.AB(a);\n\n        var q = vector.oA(b);\n        var s = vector.AB(b);\n    \n        var cross = vector.crossProduct(r,s); \n        var qmp = vector.sub(q,p);\n        var numerator = vector.crossProduct(qmp, s);\n        var t = numerator / cross;\n        var intersection = vector.add(p,vector.scalarMult(t,r));\n        return intersection;\n    };\n    self.isParallel = function(a,b) {\n        // a and b are line segments. \n        // returns true if a and b are parallel (or co-linear)\n        var r = vector.AB(a);\n        var s = vector.AB(b);\n        return (vector.crossProduct(r,s) === 0);\n    };\n    self.isCollinear = function(a,b) {\n        // a and b are line segments. \n        // returns true if a and b are co-linear\n        var p = vector.oA(a);\n        var r = vector.AB(a);\n\n        var q = vector.oA(b);\n        var s = vector.AB(b);\n        return (vector.crossProduct(vector.sub(p,q), r) === 0);\n    };\n    self.safeIntersect = function(a,b) {\n        if (self.isParallel(a,b) === false) {\n            return self.intersectSegments(a,b);\n        } else {\n            return false;\n        }\n    };\n    return self;\n};\nintersection.intersectSegments = intersection().intersectSegments;\nintersection.intersect = intersection().safeIntersect;\nintersection.isParallel = intersection().isParallel;\nintersection.isCollinear = intersection().isCollinear;\nintersection.describe = function(a,b) {\n    var isCollinear = intersection().isCollinear(a,b);\n    var isParallel = intersection().isParallel(a,b);\n    var pointOfIntersection = undefined;\n    if (isParallel === false) {\n        pointOfIntersection = intersection().intersectSegments(a,b);\n    }\n    return {collinear: isCollinear,parallel: isParallel,intersection:pointOfIntersection};\n};\nexports = module.exports = intersection;\n",
    "var SortedList = require('./sorted-linked-list.js');\n// AET is sorted list of bounds along x axis for xBot of current segment.\n// in AET each node data is bound linked list instance of FastList \n// edge = this.head.datum._head\n\nvar AET = function(options) {\n  var precision = options && options.precistion ? options.precision : -5;\n  this.constructor({compare: function(a,b){\n    //TODO need to check for horizontal and vertical lines\n    //TODO apply precision in ST compare function\n    if (Math.round10(a._head.data.xBot,precision) ===\n      Math.round10(b._head.data.xBot,precision)) {\n      var xBot = a._head.data.xBot;\n      var segA = a._head.data.segment;\n      var segB = b._head.data.segment;\n      var d1 = Math.round10(Math.abs(segA.end.x - segB.end.x),precision);\n      var d2 = Math.round10(\n        Math.abs(segB.end.x - xBot) + Math.abs(xBot - segA.end.x)\n        , precision);\n      if ( d1 === d2) {\n        // i.e. one edn on left and another on right of xBot\n        return segA.end.x - segB.end.x;\n      //} else if (segA.end.x > xBot && segB.end.x > xBot) {\n      //  return 1.0/b._head.data.deltaX - 1.0/a._head.data.deltaX;\n      } else {\n        // both end are either side of xbot\n        return 1.0/b._head.data.deltaX - 1.0/a._head.data.deltaX;\n      }\n    } else {\n      return a._head.data.xBot - b._head.data.xBot;\n    }\n  }});\n};\n\nAET.prototype = new SortedList();\nAET.prototype.getHead = function() {\n  return this.head;\n};\nAET.prototype.getHeadData = function() {\n  return this.head.datum.getHeadData();\n};\nAET.prototype.getData = function(edge) {\n  return edge.datum.getHeadData();\n};\nAET.prototype.getBound = function(edge) {\n  return edge.datum;\n};\nAET.prototype.isContributing = function(bound) {\n  //check if edge is contributing by even/odd rule\n  var leftCount = this.lowerBound(bound)\n    .filter(function(bound) {\n      return bound.getHeadData().type === this[0];\n    },[opposite(bound.getHeadData().type)]);\n  return leftCount.length % 2 !== 0;\n};\nAET.prototype.getSide = function(bound) {\n  var leftCount = this.lowerBound(bound)\n    .filter(function(bound) {\n      return bound.getHeadData().type === this[0];\n    },[bound.getHeadData().type]);\n    return leftCount.length % 2 == 0 ? 'left' : 'right';\n};\n\nAET.prototype.succ = function(edge) {\n  var bound = edge.datum;\n  //this.remove(bound);\n  bound.shift();\n  //return this.insert(bound);\n  return edge;\n};\n\nAET.prototype.swap = function(bound1,bound2) {\n  //considering bound1 and bound2 are consicutive and boound2 would never be head \n  // consider oreder a,b,c,d and replacing b,c will result a,c,b,d\n  var b = this.find(bound1);\n  var c = this.find(bound2);\n  if (b == this.head && c == this.tail) {\n    this.tail = b;\n    this.head = c;\n    return this;      \n  } else if (b == this.head) {\n    this.head = c;\n  } else if (c == this.tail) {\n    this.tail = b;\n  }\n  var a = b.prev;\n  var d = c.next;\n\n  b.prev = c;\n  b.next = d;\n  d.prev = b;\n\n  c.next = b;\n  c.prev = a;\n  a.next = c;\n  return this;\n};\nAET.prototype.insertAfter = function(a, b) {\n  if (b === this.tail) {\n    a.next = this.head;\n    this.tail = a;\n    this.head.prev = this.tail;\n  } else {\n    a.next = b.next;\n    b.next.prev = a;\n  }\n  a.prev = b;\n  return b.next = a;\n};\n\nfunction opposite(type) {\n  return type === 'subject' ? 'clip' : 'subject';\n}\nmodule.exports = AET;\n",
    "var FastList = require('fast-list');\n\n// bound(left/right) is linked list of polygon semgents. Polygon segments are\n// pushed from local minima to maxima in bound's linked-list. So head of bound\n// (linked list) is always at lowermost segment while we keep on removing \n// (shifing) the items in linked list during the scaning from bottom to top.\n\nvar Bound = function() {};\nBound.prototype = new FastList();\n\nBound.prototype.getHeadData = function() {\n  return this._head.data;\n};\nBound.prototype.getHead = function() {\n  return this._head;\n};\n\nmodule.exports = Bound;\n\n",
    "var intersection = require('intersection');\nvar FastList = require('fast-list'); \nvar geojsonAllRings = require('geojson-allrings');\nvar getLocalMinimaList = require('./local-minima-list.js');\nvar List = require('./sorted-linked-list.js');\nvar AETClass = require('./aet.js');\nvar STClass = require('./st.js');\nvar ITClass = require('./it.js');\nvar Polygon = require('./polygon.js');\n//TODO check how to include closure / or one time execution of function\nvar Precision = require('./precision.js');\n// AET is sorted list of bounds along x axis.\n// each data item in AET is bound(left/right) i.e. linked list of polygon semgents\n// polygon segments are pushed from local minima to maxima in bound's linked-list\n// so head is always at lowermost segment while we keep on removing(shifing) \n// the items in linked list during the scaning from down to top.\n// So this way actualy I am able to sort first edge of bound in AET, while also\n// have access to next pointer in the bound linked list.\nvar Clipper = function() {\n};\nClipper.prototype.overlay = function(subj,clip,process) {\n  this.AET = new AETClass();\n  this.PT = [];\n  this.SBT = new List();\n  this.LMT = new List({compare: function(a,b) {\n    return a.yBot - b.yBot;\n  }});\n  this.IT = null;\n  // insert local minima node i.e. object of left and  right bound and yBot\n  this.updateLMTandSBT(subj,'subject');\n  this.updateLMTandSBT(clip,'clip');\n  var yBot = this.SBT.pop(),yTop;\n  while (this.SBT.head) {\n    while (this.LMT.head && Math.round10(this.LMT.head.datum.yBot,-5) ===\n      Math.round10(yBot,-5)) {\n      this.addEdgesOfLMT(this.LMT.pop());\n    }\n    yTop = this.SBT.pop();\n    //console.log('yBot: '+ yBot + ' ,yTop: '+ yTop);\n    this.buildIntersections(yBot,yTop);\n    this.processIntersections();\n    this.processAETedges(yBot,yTop);\n    yBot = yTop;\n  }\n  /*var output = { \n    exterior: {\"type\": \"MultiPolygon\", coordinates:[[]]},\n    holes: []};\n  polygons.forEach(function (poly) {\n    if (poly.isHole) {\n      output.holes.push(poly.getCoordinates());\n    } else {\n      output.exterior.coordinates[0].push(poly.getCoordinates());\n    }\n  });*/\n  return this.extractPolygon();\n};\nClipper.prototype.extractPolygon = function() {\n  var output = {\"type\": \"MultiPolygon\", \"coordinates\": []},\n    exteriors =[],\n    holes = {};\n  this.PT\n    .filter(function (poly) {\n      //remove polygon that are merged to another polygons\n      return poly.left && poly.right;})\n    .forEach(function (poly) {\n      if(poly.isHole) {\n        holes[poly.id] = {coordinates: poly.getCoordinates()};          \n      } else {\n        exteriors.push({coordinates: poly.getCoordinates(),\n          holeIds: poly.holeIds});\n      }\n    });\n  // append holes to exterior\n  exteriors.forEach(function(poly) {\n    var coordinates = [poly.coordinates];\n    poly.holeIds.forEach(function(id) {\n      coordinates.push(holes[id].coordinates);});\n    output.coordinates.push(coordinates);\n  });\n  return output;\n};\nClipper.prototype.updateLMTandSBT = function(poly,type) {\n  if (poly.type && poly.type === 'Polygon') {\n    this.updateLMTandSBTwithPolygon(poly,type);\n  } else if (poly.type && poly.type === 'MultiPolygon') {\n    poly.coordinates.forEach(function(each) {\n      this.updateLMTandSBTwithPolygon({type:'Polygon',coordinates:each},type)\n    },this);\n  } else if (poly.type && poly.type === 'Feature') {\n    this.updateLMTandSBTwithPolygon(poly.geometry,type);\n  } else if (poly.type && poly.type === 'FeatureCollection') {\n    poly.features.forEach(function(pg) {\n      this.updateLMTandSBTwithPolygon(pg.geometry,type);\n    },this);\n  } else {\n     //TODO throw error\n  }\n};\nClipper.prototype.updateLMTandSBTwithPolygon = function(poly,type) {\n  geojsonAllRings(poly).forEach(function (ring) {\n    getLocalMinimaList(ring,type).forEach(function(node){\n      this.LMT.insert(node);\n      //TODO finding node in sorted list is expensive\n      if (!this.SBT.find(node.yBot)) this.SBT.insert(node.yBot);\n    }, this);\n  }, this);\n};\n//NOTE: every where edge means head of bound \n// always insert/attach in AET, ST, intersection point, polygon edge etc\nClipper.prototype.addEdgesOfLMT = function(node) {\n  //TODO-vatti first insert in AET then addLocalMin if edges are cotributing\n  this.AET.insert(node.left);\n  this.AET.insert(node.right);\n  node.left.getHeadData().side = this.AET.getSide(node.left);\n  node.right.getHeadData().side = this.AET.getSide(node.right);\n  // left is not necessary edge1\n  if(this.AET.isContributing(node.left)) {\n    this.addLocalMin(\n      node.left.getHeadData().segment.start,\n      node.left,\n      node.right);\n  }\n  //TODO finding node in sorted list is expensive\n  if (!this.SBT.find(node.left.getHeadData().yTop)) {\n    this.SBT.insert(node.left.getHeadData().yTop);\n  }\n  if (!this.SBT.find(node.right.getHeadData().yTop)) {  \n    this.SBT.insert(node.right.getHeadData().yTop);\n  }\n};\n// each polygon is linked list (not sroted linked list) of left side edges \n// and right side edges.\nClipper.prototype.addLocalMin = function(point,edge1,edge2) {\n  var poly = new Polygon(this.PT.length);\n  poly.addLeft(point);\n  poly.addRight(point);\n  edge1.getHeadData().polygon = poly;\n  edge2.getHeadData().polygon = poly;\n  this.PT.push(poly);\n  return poly;\n};\n\nClipper.prototype.addLocalMax = function(point,edge1,edge2) {\n  if(edge1.getHeadData().side === 'left') {\n    this.addLeft(point,edge1);\n  } else {\n    this.addRight(point,edge1);\n  }\n  var poly1 = edge1.getHeadData().polygon,\n    poly2 = edge2.getHeadData().polygon;\n   \n  if(!poly1.isEqual(poly2)) {\n    poly2.appendPolygon(poly1,edge1.getHeadData().side);\n    // change ref to edge2->polygon from edge1->polygon for all active edges \n    // that have edge1->polygon\n    var curPoly, cur = this.AET.head;\n    do {\n      curPoly = this.AET.getData(cur).polygon;\n      if (curPoly && curPoly.id === poly1.id) {\n        this.AET.getData(cur).polygon = poly2;\n      }\n      cur = cur.next;\n    } while (cur !== this.AET.head);\n  }\n  poly2.isHole = edge1.getHeadData().side === 'right';\n  if(poly2.isHole) {\n    this.assignToExterior(poly2,edge1,edge2);\n  }\n};\n\nClipper.prototype.buildIntersections = function(yBot,yTop) {\n  var dY = yTop - yBot;\n  ST = new STClass();\n  this.IT = new ITClass(); \n  var intPoint;\n  //initiate the first edge in ST\n  var AETedge = this.AET.getHead(); \n  var xTop = this.AET.getData(AETedge).xBot + this.AET.getData(AETedge).deltaX * dY;\n  this.AET.getData(AETedge).xTop = xTop;\n  this.AET.getData(AETedge).isProcessed = false; //used in processAETedges\n  var STedge = ST.insert(this.AET.getBound(AETedge)); //return the ref to inserted data\n\n  AETedge = AETedge.next;\n  while( AETedge !== this.AET.head) {\n    this.AET.getData(AETedge).isProcessed = false; //used in processAETedges\n    xTop = this.AET.getData(AETedge).xBot + this.AET.getData(AETedge).deltaX * dY;\n    //check intersections\n    //TODO what if xTop == STedge.xTop\n    while(Math.round10(xTop,-5) < Math.round10(ST.getData(STedge).xTop,-5)) {\n      intPoint = intersection.intersect(ST.getData(STedge).segment,\n        this.AET.getData(AETedge).segment);\n      //attaching head of the bound to int point\n      intPoint.leftEdge = ST.getBound(STedge); // considering the bottom x\n      intPoint.rightEdge = this.AET.getBound(AETedge);\n      this.IT.insert(intPoint);\n      if(STedge === ST.head) break;\n      STedge = STedge.prev;\n    }\n    this.AET.getData(AETedge).xTop = xTop;\n    ST.insert(this.AET.getBound(AETedge)); //TODO is should be insert before STedge\n    STedge= ST.tail;\n    AETedge = AETedge.next;\n  }\n};\n\nClipper.prototype.processIntersections = function() {\n  var intPoint = this.IT.getHead();\n  if (intPoint) {\n    var intPointType,edge1,edge2, temp, isContributing;\n    do {\n      edge1 = this.IT.getData(intPoint).leftEdge;\n      edge2 = this.IT.getData(intPoint).rightEdge;\n      intPointType = this.classifyIntersection(edge1.getHeadData(), edge2.getHeadData());\n      if (edge1.getHeadData().type === edge2.getHeadData().type) {\n        //&& edge1.getHeadData().side !== edge2.getHeadData().side) {\n        // like edges\n        // TODO test case need to be checked\n        if(this.AET.isContributing(edge1)) {\n          if (edge1.getHeadData().side === 'left') {\n            this.addLeft(this.IT.getData(intPoint),edge1);\n            this.addRight(this.IT.getData(intPoint),edge2);\n          } else {\n            this.addRight(this.IT.getData(intPoint),edge1);\n            this.addLeft(this.IT.getData(intPoint),edge2);\n          }\n        }\n        temp = edge1.getHeadData().side;\n        edge1.getHeadData().side = edge2.getHeadData().side;\n        edge2.getHeadData().side = temp;\n      } else {\n        //TODO checking edge polygon is not part fo vatii algo\n        if (intPointType === 'maxima' && edge1.getHeadData().polygon \n          && edge2.getHeadData().polygon) {\n          this.addLocalMax(this.IT.getData(intPoint),edge1,edge2);\n        } else if (intPointType === 'left-intermediate' \n          && edge2.getHeadData().polygon) {\n          this.addLeft(this.IT.getData(intPoint),edge2);\n        } else if (intPointType === 'right-intermediate' \n          && edge1.getHeadData().polygon) {\n          this.addRight(this.IT.getData(intPoint),edge1);\n        } else if (intPointType === 'minima') {\n          this.addLocalMin(this.IT.getData(intPoint),edge1,edge2);\n        }\n      }\n      this.AET.swap(edge1,edge2);\n      //TODO can be done in if intPointType accordingly \n      //swap polygons\n      temp = edge1.getHeadData().polygon;\n      edge1.getHeadData().polygon = edge2.getHeadData().polygon;\n      edge2.getHeadData().polygon = temp;\n      //TODO why not recalculate side of edges\n      intPoint = intPoint.next;\n    } while (intPoint !== this.IT.head );\n  }\n};\n\nClipper.prototype.processAETedges = function(yBot,yTop) {\n  var cur = this.AET.getHead(),\n    vertexType,data,isContributing,prev;\n  if (cur) {\n    do { \n      this.AET.getData(cur).isProcessed = true;\n      isContributing = this.AET.isContributing(this.AET.getBound(cur));\n      //TODO vatti algo doesnt cal isContributing, can we carry forward like\n        // side\n      if (Math.round10(this.AET.getData(cur).yTop,-5) === Math.round10(yTop,-5)) {\n        vertexType = this.AET.getData(cur).segment.end.type;\n        if (vertexType === 'maxima') {\n          if(isContributing) { \n            this.addLocalMax(this.AET.getData(cur).segment.end,this.AET.getBound(cur),\n              this.AET.getBound(cur.next));\n          }\n          var e1 = cur;\n          var e2 = cur.next;\n          cur = cur.next.next;\n          this.AET.remove(e1.datum);\n          this.AET.remove(e2.datum);\n        } else {\n          vertexType = this.AET.getData(cur).side + '-' + vertexType;\n          if (vertexType === 'left-intermediate') {\n            if(isContributing) {\n              this.addLeft(this.AET.getData(cur).segment.end,this.AET.getBound(cur));\n            }\n          } else if (vertexType === 'right-intermediate') {\n            if(isContributing) {\n              this.addRight(this.AET.getData(cur).segment.end,this.AET.getBound(cur));\n            }\n          }\n          data = this.AET.getData(cur);\n          cur = this.AET.succ(cur); //returns ref to same bound but moved to \n            // upper edge\n          this.AET.getData(cur).side = data.side;\n          //this.AET.getData(cur).isContributing = data.isContributing;\n          this.AET.getData(cur).polygon = data.polygon;\n          this.AET.getData(cur).isProcessed = true; //TODO sorted-'circular'-linked-list\n            // is creating so many issue in while loop\n          //TODO finding node in sorted list is expensive\n          if (!this.SBT.find(this.AET.getData(cur).yTop)) \n            this.SBT.insert(this.AET.getData(cur).yTop);\n          cur = cur.next;\n        }\n      } else {\n        this.AET.getData(cur).xBot = this.AET.getData(cur).xTop; \n        cur = cur.next;\n      }\n    //} while (cur !== this.AET.head && this.AET.length > 0);\n    } while (!this.AET.getData(cur).isProcessed)\n  }\n};\n\nClipper.prototype.addLeft = function(point,bound) {\n  bound.getHeadData().polygon.addLeft(point);\n};\nClipper.prototype.addRight = function(point,bound) {\n  bound.getHeadData().polygon.addRight(point);\n};\nClipper.prototype.assignToExterior = function(polygon, edge1,edge2) {\n  var leftExteriorId, rightExteriorId,\n    leftEdge, rightEdge,\n    AETedge1 = this.AET.find(edge1),\n    edgeData;\n  var cur = AETedge1 ? AETedge1.prev : null; \n  if(cur) {\n    do {\n      edgeData = this.AET.getData(cur);\n      if (edgeData.polygon && edgeData.isHole) {\n        cur = cur.prev; \n      } else {\n        if(edgeData.side === 'left') {\n          if (edgeData.polygon.holeIds.indexOf(polygon.id) < 0) {\n            //edgeData.polygon.holeIds.push(polygon.id);\n            leftEdgeData = edgeData;\n          }\n        }\n        break;\n      }\n    } while (cur !== this.AET.tail);\n  }\n  cur = AETedge1 ? AETedge1.next.next : null; //AETedge1.next is edge2\n  if(cur) {\n    do {\n      edgeData = this.AET.getData(cur);\n      if (edgeData.polygon && edgeData.isHole) {\n        cur = cur.next;\n      } else {\n        if(edgeData.side === 'right') {\n          if (edgeData.polygon.holeIds.indexOf(polygon.id) < 0) {\n            //edgeData.polygon.holeIds.push(polygon.id);\n            rightEdgeData = edgeData;\n          }\n        }\n        break;\n      }\n    } while (cur !== this.AET.head);\n  }\n  if(leftEdgeData.polygon.id !== polygon.id && \n    leftEdgeData.polygon.id === rightEdgeData.polygon.id) {\n    leftEdgeData.polygon.holeIds.push(polygon.id);\n  }\n};\nClipper.prototype.classifyIntersection = function(edge1,edge2) {\n  var rules = { \n    'left-clip-x-left-subject': 'left-intermediate',\n    'left-subject-x-left-clip': 'left-intermediate',\n    'right-clip-x-right-subject': 'right-intermediate',\n    'right-subject-x-right-clip': 'right-intermediate',\n    'left-subject-x-right-clip': 'maxima',\n    'left-clip-x-right-subject': 'maxima',\n    'right-subject-x-left-clip': 'minima',\n    'right-clip-x-left-subject': 'minima'\n  };\n  return rules[edge1.side + '-' + edge1.type +'-x-' + edge2.side + '-'+ edge2.type];\n};\n\nmodule.exports = Clipper;\n",
    "var SortedList = require('./sorted-linked-list.js');\n\nvar IT = function() {\n  this.constructor({compare: function(a,b) {\n    //TODO -5 should be variable\n    return Math.round10(a.y,-5) - Math.round10(b.y,-5);\n  }});\n};\nIT.prototype = new SortedList();\nIT.prototype.getHead = function() {\n  return this.head;\n};\nIT.prototype.getHeadData = function() {\n  return this.head.datum.headData();\n};\nIT.prototype.getData = function(intersection) {\n  return intersection.datum;\n};\nmodule.exports = IT;\n",
    "// local-min-max.js\n// input close path i.e. first point and last point are equal\n// return array of tags local minima, maxima and intermediate at each point\nvar Bound = require('./bound.js');\nvar List = require('./sorted-linked-list.js');\nfunction getBounds(path,polygonType) {\n  var bounds = [],\n    partBound = [],\n    totalDet = 0,\n    bound = [],\n    vertex = {},type;\n  bound.det = 0;\n  for(var i= 0; i < path.length; i++) {\n    if (i < path.length -1 || (i == path.length - 1 && partBound.length == 0)) {\n      type = getNodeType(i,path);\n      vertex = {x: path[i][0],y: path[i][1], type: type };\n      bound.push(vertex);\n      bound.det += i=== path.length -1 ? \n        getDet({x:path[i][0], y:path[i][1]}, {x:path[1][0], y:path[1][1]})\n        : getDet({x:path[i][0],y:path[i][1]}, {x:path[i+1][0],y:path[i+1][1]});\n      if(vertex.type === 'maxima') {\n        totalDet += bound.det;\n        if(bound[0].type === 'maxima') {\n          if (i !== 0) bound.det += getDet(vertex,bound[0]);\n          if (bound.length > 1) bounds.push(bound);\n        } else {\n          partBound = bound;  \n        }\n        bound = [], bound.det = 0;\n        bound.push(vertex);\n      } else if (vertex.type === 'minima') {\n        bound.minPos = bound.length - 1;\n      }\n    }\n  }\n  if (partBound.length > 0) {\n    //join with part bound\n    var det = bound.det + partBound.det \n      + getDet(partBound[partBound.length-1],bound[0]);\n    var minPos = bound.minPos ? bound.minPos \n      : partBound.minPos + bound.length; \n    bound = bound.concat(partBound);\n    bound.minPos = minPos;\n    bound.det = det;\n    totalDet += bound.det;\n    bounds.push(bound);\n  }\n  var LML = [],left,right;\n  for (var i=0;i< bounds.length; i++) {\n    //check orientation(+ve/-ve) of path and bounds convex/concave\n    //if (totalDet * bounds[i].det > 0) { //so indiv bound doesn't matter\n      // TODO so can use signed area insteade of calculating the totalDet\n    if (totalDet > 0) { \n        leftBound = bounds[i].slice(0,bounds[i].minPos+1).reverse();\n        rightBound = bounds[i].slice(bounds[i].minPos,bounds[i].length);\n    } else {\n        rightBound = bounds[i].slice(0,bounds[i].minPos+1).reverse();\n        leftBound = bounds[i].slice(bounds[i].minPos,bounds[i].length);\n    }\n    LML.push({\n      left: initiateEdges(leftBound,'left',polygonType),\n      right: initiateEdges(rightBound,'right',polygonType),\n      yBot: leftBound[0].y});   \n  }\n  return LML; \n}\nfunction sign(val) {\n  return val > 0 ? 1 : -1;\n}\nfunction getDet(cur,next) {\n  //return cur[0]*next[1] - cur[1]*next[0];\n  return cur.x * next.y - cur.y * next.x;\n}\nfunction getNodeType(ind,path) {\n  var prev, cur = path[ind], next; \n  if (ind === 0) {\n    prev = path[path.length - 2];\n    next = path[ind + 1];\n  } else if (ind === path.length - 1) {\n    prev = path[ind -1];\n    next = path[1]; \n  } else {\n    prev = path[ind - 1];\n    next = path[ind + 1];\n  }\n  if(cur[1] > prev[1] && cur[1] > next[1]) {\n    return 'maxima';\n  } else if(cur[1] < prev[1] && cur[1] < next[1]) {\n    return 'minima';\n  } else {\n    return 'intermediate';\n  }\n}\n\nfunction _initiateEdges(points,side,type) {\n  var list = new List({compare: function(a,b) {\n    return a.segment.start.y - b.segment.start.y; \n  }});\n  var edge = {side: side,type: type};\n  for(var i=0; i<points.length - 1; i++) {\n    edge.segment = { start: points[i], end: points[i+1] };\n    edge.xBot = points[i].x;\n    edge.yTop = points[i+1].y;\n    edge.deltaX = (points[i+1].x - points[i].x)\n      / (points[i+1].y - points[i].y);\n    list.insert(edge);\n  }\n  return list;\n}\n\nfunction initiateEdges(points,side,type) {\n  //TODO-vatti remove side its assigned based on position in polygon(can check in AET)\n  var list = new Bound();\n  var edge;\n  for(var i=0; i<points.length - 1; i++) {\n    edge = {side: side,type: type};\n    edge.segment = { start: points[i], end: points[i+1] };\n    edge.xBot = points[i].x;\n    edge.yTop = points[i+1].y;\n    edge.deltaX = (points[i+1].x - points[i].x)\n      / (points[i+1].y - points[i].y);\n    list.push(edge);\n  }\n  return list;\n}\nmodule.exports = getBounds;\n",
    "var Polygon = function(id) {\n  this.id = id;\n  this.left = [];\n  this.right = [];\n  this.isHole = false;\n  this.holeIds = [];\n};\n\n// assuming always append edge1 polygon to edge2 and 'this' is edge2 polygon \n// 'side' is side of edge1 \nPolygon.prototype.appendPolygon = function(polygon,side) {\n  if (side === 'right' ) {\n    var left = this.left\n      .concat(polygon.right.reverse().slice(0,polygon.right.length - 1))\n      .concat(polygon.left);\n    this.left = left;\n  } else { \n    var right = this.right\n      .concat(polygon.left.reverse().slice(0,polygon.left.length - 1))\n      .concat(polygon.right);\n    this.right = right;\n  }\n  polygon.left = null;\n  polygon.right = null;\n  return this;\n};\n\nPolygon.prototype.addLeft = function(point) {\n  this.left.push(point);\n  return this;\n};\nPolygon.prototype.addRight = function(point) {\n  this.right.push(point);\n  return this;\n};\nPolygon.prototype.extend = function(polygon) {\n  //this.id = polygon.id;\n  this.left = polygon.left;\n  this.right = polygon.right;\n  return this;\n};\n\nPolygon.prototype.isEqual = function(polygon) {\n  //return this.id === polygon.id;\n  return this.left === polygon.left && this.right === polygon.right;\n};\nPolygon.prototype.getCoordinates = function() {\n  return this.right.concat(this.left.reverse())\n    .map(function(pt) {\n      return [pt.x, pt.y];\n    });\n};\nmodule.exports = Polygon;\n",
    "//taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round\n// Closure\n(function(){\n\n  /**\n   * Decimal adjustment of a number.\n   *\n   * @param {String}  type  The type of adjustment.\n   * @param {Number}  value The number.\n   * @param {Integer} exp   The exponent (the 10 logarithm of the adjustment base).\n   * @returns {Number}      The adjusted value.\n   */\n  function decimalAdjust(type, value, exp) {\n    // If the exp is undefined or zero...\n    if (typeof exp === 'undefined' || +exp === 0) {\n      return Math[type](value);\n    }\n    value = +value;\n    exp = +exp;\n    // If the value is not a number or the exp is not an integer...\n    if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) {\n      return NaN;\n    }\n    // Shift\n    value = value.toString().split('e');\n    value = Math[type](+(value[0] + 'e' + (value[1] ? (+value[1] - exp) : -exp)));\n    // Shift back\n    value = value.toString().split('e');\n    return +(value[0] + 'e' + (value[1] ? (+value[1] + exp) : exp));\n  }\n\n  // Decimal round\n  if (!Math.round10) {\n    Math.round10 = function(value, exp) {\n      return decimalAdjust('round', value, exp);\n    };\n  }\n  // Decimal floor\n  if (!Math.floor10) {\n    Math.floor10 = function(value, exp) {\n      return decimalAdjust('floor', value, exp);\n    };\n  }\n  // Decimal ceil\n  if (!Math.ceil10) {\n    Math.ceil10 = function(value, exp) {\n      return decimalAdjust('ceil', value, exp);\n    };\n  }\n\n})();\n",
    "// Generated by CoffeeScript 1.4.0\nvar Node, SortedCircularDoublyLinkedList;\n\nNode = (function() {\n\n  function Node(datum, prev, next) {\n    this.datum = datum;\n    this.prev = prev;\n    this.next = next;\n  }\n\n  return Node;\n\n})();\n\nSortedCircularDoublyLinkedList = (function() {\n\n  function SortedCircularDoublyLinkedList(options) {\n    var opt = options || {};\n    this.head = opt.head;\n    this.tail = opt.tail;\n    this.length = 0;\n    if( opt.compare) \n      this.compare = opt.compare; \n  }\n\n  SortedCircularDoublyLinkedList.prototype.compare = function(datum1, datum2) {\n    return datum1 - datum2;\n  };\n\n  SortedCircularDoublyLinkedList.prototype.insertAll = function(list) {\n    var x, _i, _len;\n    if (list == null) {\n      list = [];\n    }\n    for (_i = 0, _len = list.length; _i < _len; _i++) {\n      x = list[_i];\n      this.insert(x);\n    }\n    return this.head;\n  };\n\n  SortedCircularDoublyLinkedList.prototype.insert = function(datum) {\n    var current, insertAfter, insertBefore, next, node;\n    node = new Node(datum);\n    insertBefore = function(a, b) {\n      if (b === this.head) {\n        a.prev = this.tail;\n        this.head = a;\n        this.tail.next = this.head;\n      } else {\n        a.prev = b.prev;\n        b.prev.next = a;\n      }\n      a.next = b;\n      return b.prev = a;\n    };\n    insertAfter = function(a, b) {\n      if (b === this.tail) {\n        a.next = this.head;\n        this.tail = a;\n        this.head.prev = this.tail;\n      } else {\n        a.next = b.next;\n        b.next.prev = a;\n      }\n      a.prev = b;\n      return b.next = a;\n    };\n    this.length++; //TODO it should be before return statement\n    if (this.head == null) {\n      this.head = node;\n      this.head.next = node;\n      this.head.prev = node;\n      this.tail = this.head;\n      return node;\n    }\n    if (this.compare(this.head.datum, node.datum) > 0) {\n      insertBefore(node, this.head);\n      this.head = node;\n    } else {\n      current = this.head;\n      while (current !== this.tail) {\n        next = current.next;\n        if (this.compare(next.datum, node.datum) > 0) {\n          break;\n        }\n        current = current.next;\n      }\n      insertAfter(node, current);\n      if (current === this.tail) {\n        this.tail = node;\n      }\n    }\n    /*if (this.compare(node.datum, this.head.datum) < 0) {\n      this.head = node;\n    }\n    if (this.compare(node.datum, this.tail.datum) > 0) {\n      this.tail = node;\n    }*/\n    return node;\n  };\n\n  SortedCircularDoublyLinkedList.prototype.remove = function(datum) {\n    var current;\n    current = this.head;\n    //TODO can be current.datum !== datum\n    //while (this.compare(current.datum, datum) !== 0) {\n    while (current.datum !== datum) {\n      current = current.next;\n      if (current === this.head) {\n        break;\n      }\n    }\n    this.length--;\n    if(current === this.head && current === this.tail) {\n      this.head = null;\n      this.tail = null;\n    } else {\n      if (current === this.head) {\n        this.head = current.next;\n        this.tail.next = this.head;\n        this.head.prev = this.tail;\n      } else {\n        current.prev.next = current.next;\n      }\n      if (current === this.tail) {\n        this.tail = current.prev;\n        this.head.prev = this.tail;\n        return this.tail.next = this.head;\n      } else {\n        return current.next.prev = current.prev;\n      }\n    }\n  };\n\n  SortedCircularDoublyLinkedList.prototype.contains = function(datum) {\n    return this.find(datum) != null;\n  };\n\n  SortedCircularDoublyLinkedList.prototype.find = function(datum) {\n    var current;\n    if (!this.head) {\n      return null;\n    } else {\n      current = this.head;\n      do {\n        if (this.compare(current.datum, datum) === 0) {\n          return current;\n        }\n        current = current.next;\n      } while (current !== this.head);\n      return null;\n    }\n  };\n\n  SortedCircularDoublyLinkedList.prototype.print = function() {\n    var current, output;\n    output = \"\";\n    if (!(this.head != null)) {\n      return;\n    }\n    current = this.head;\n    output += \"\" + current.datum;\n    while (current.next !== this.head) {\n      current = current.next;\n      output += \", \" + current.datum;\n    }\n    return output;\n  };\n  \n  SortedCircularDoublyLinkedList.prototype.pop = function() {\n    var datum = this.head.datum;\n    this.remove(datum);\n    return datum;\n  };\n\n  SortedCircularDoublyLinkedList.prototype.upperBound = function(datum) {\n    var upper = [];\n    var cur = this.find(datum);\n    if (cur && cur !== this.tail) {\n      do {\n        upper.push(cur.next.datum);\n        cur = cur.next;\n      } while (cur !== this.tail);\n    }\n    return upper;\n  };\n\n  SortedCircularDoublyLinkedList.prototype.lowerBound = function(datum) {\n    var lower = [];\n    var cur = this.find(datum);\n    if (cur && cur !== this.head) {\n      do {\n        lower.push(cur.prev.datum);\n        cur = cur.prev;\n      } while (cur !== this.head);\n    }\n    return lower;\n  };\n  SortedCircularDoublyLinkedList.prototype.lowerCount = function(datum) {\n    var count = 0;\n    var cur = this.find(datum);\n    if (cur && cur !== this.head) {\n      do {\n        count++;\n        cur = cur.prev;\n      } while (cur !== this.head);\n    }\n    return count;\n  };\n\n  SortedCircularDoublyLinkedList.prototype.upperCount = function(datum) {\n    var count = 0;\n    var cur = this.find(datum);\n    if (cur && cur !== this.tail) {\n      do {\n        count++;\n        cur = cur.next;\n      } while (cur !== this.tail);\n    }\n    return count;\n  };\n\n  return SortedCircularDoublyLinkedList;\n\n})();\n\nmodule.exports = SortedCircularDoublyLinkedList;\n",
    "var SortedList = require('./sorted-linked-list.js');\n// ST is sorted list of bounds along x axis for xTop of current segment.\n// in ST each node data is instance of Bound (FastList) i.e. linked list of \n// polygon segments sorted bottom to top  \n// edge = this.head.datum._head\n\nvar ST = function() {\n  this.constructor({compare: function(a,b){\n    //return a._head.data.xTop - b._head.data.xTop;  \n    //TODO need to check for horizontal and vertical lines\n    if (Math.round10(a._head.data.xTop,-5) ===\n      Math.round10(b._head.data.xTop,-5)) {\n      var xTop = a._head.data.xTop;\n      var segA = a._head.data.segment;\n      var segB = b._head.data.segment;\n      if (Math.round10(Math.abs(segA.start.x - segB.start.x),-5) ===\n          Math.round10(\n            Math.abs(segB.start.x - xTop) + Math.abs(xTop - segA.start.x)\n            ,-5)) \n      {\n        // i.e. one end on left and another on right of xTop\n        return segA.start.x - segB.start.x;\n      //} else if (segA.start.x > xTop && segB.start.x > xTop) {\n      //  return 1.0/b._head.data.deltaX - 1.0/a._head.data.deltaX;\n      } else {\n        // both end are either side of xTop\n        return 1.0/a._head.data.deltaX - 1.0/b._head.data.deltaX;\n      }\n    } else {\n      return a._head.data.xTop - b._head.data.xTop;\n    }\n  }});\n};\n\nST.prototype = new SortedList();\nST.prototype.getHead = function() {\n  return this.head;\n};\nST.prototype.getHeadData = function() {\n  return this.head.datum.getHeadData();\n};\nST.prototype.getData = function(edge) {\n  return edge.datum.getHeadData();\n};\nST.prototype.getBound = function(edge) {\n  return edge.datum;\n};\n\nmodule.exports = ST;\n"
  ]
}